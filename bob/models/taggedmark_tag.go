// Code generated by BobGen sqlite v0.15.5. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"errors"
	"fmt"

	"github.com/aarondl/opt/omit"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/sqlite"
	"github.com/stephenafamo/bob/dialect/sqlite/dialect"
	"github.com/stephenafamo/bob/dialect/sqlite/sm"
	"github.com/stephenafamo/bob/orm"
)

// TaggedmarkTag is an object representing the database table.
type TaggedmarkTag struct {
	TagID        int64  `db:"tag_id,pk" json:"tag_id" toml:"tag_id" yaml:"tag_id"`
	TaggedmarkID int64  `db:"taggedmark_id" json:"taggedmark_id" toml:"taggedmark_id" yaml:"taggedmark_id"`
	UpdateTime   string `db:"update_time" json:"update_time" toml:"update_time" yaml:"update_time"`

	R taggedmarkTagR `db:"-" json:"-" toml:"-" yaml:"-"`
}

// TaggedmarkTagSlice is an alias for a slice of pointers to TaggedmarkTag.
// This should almost always be used instead of []TaggedmarkTag.
type TaggedmarkTagSlice []*TaggedmarkTag

// TaggedmarkTagsTable contains methods to work with the taggedmark_tag table
var TaggedmarkTagsTable = sqlite.NewTablex[*TaggedmarkTag, TaggedmarkTagSlice, *TaggedmarkTagSetter]("", "taggedmark_tag")

// TaggedmarkTagsQuery is a query on the taggedmark_tag table
type TaggedmarkTagsQuery = *sqlite.TableQuery[*TaggedmarkTag, TaggedmarkTagSlice, *TaggedmarkTagSetter]

// TaggedmarkTagsStmt is a prepared statment on taggedmark_tag
type TaggedmarkTagsStmt = bob.QueryStmt[*TaggedmarkTag, TaggedmarkTagSlice]

// taggedmarkTagR is where relationships are stored.
type taggedmarkTagR struct {
	Taggedmark *Taggedmark `db:"Taggedmark" json:"Taggedmark" toml:"Taggedmark" yaml:"Taggedmark"`
	Tag        *Tag        `db:"Tag" json:"Tag" toml:"Tag" yaml:"Tag"`
}

// TaggedmarkTagSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type TaggedmarkTagSetter struct {
	TagID        omit.Val[int64]  `db:"tag_id,pk"`
	TaggedmarkID omit.Val[int64]  `db:"taggedmark_id"`
	UpdateTime   omit.Val[string] `db:"update_time"`
}

type taggedmarkTagColumnNames struct {
	TagID        string
	TaggedmarkID string
	UpdateTime   string
}

var TaggedmarkTagColumns = struct {
	TagID        sqlite.Expression
	TaggedmarkID sqlite.Expression
	UpdateTime   sqlite.Expression
}{
	TagID:        sqlite.Quote("taggedmark_tag", "tag_id"),
	TaggedmarkID: sqlite.Quote("taggedmark_tag", "taggedmark_id"),
	UpdateTime:   sqlite.Quote("taggedmark_tag", "update_time"),
}

type taggedmarkTagWhere[Q sqlite.Filterable] struct {
	TagID        sqlite.WhereMod[Q, int64]
	TaggedmarkID sqlite.WhereMod[Q, int64]
	UpdateTime   sqlite.WhereMod[Q, string]
}

func TaggedmarkTagWhere[Q sqlite.Filterable]() taggedmarkTagWhere[Q] {
	return taggedmarkTagWhere[Q]{
		TagID:        sqlite.Where[Q, int64](sqlite.Quote("taggedmark_tag", "tag_id")),
		TaggedmarkID: sqlite.Where[Q, int64](sqlite.Quote("taggedmark_tag", "taggedmark_id")),
		UpdateTime:   sqlite.Where[Q, string](sqlite.Quote("taggedmark_tag", "update_time")),
	}
}

// TaggedmarkTags begins a query on taggedmark_tag
func TaggedmarkTags(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) TaggedmarkTagsQuery {
	return TaggedmarkTagsTable.Query(ctx, exec, mods...)
}

// FindTaggedmarkTag retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindTaggedmarkTag(ctx context.Context, exec bob.Executor, TagIDPK int64, cols ...string) (*TaggedmarkTag, error) {
	if len(cols) == 0 {
		return TaggedmarkTagsTable.Query(
			ctx, exec,
			SelectWhere.TaggedmarkTags.TagID.EQ(TagIDPK),
		).One()
	}

	return TaggedmarkTagsTable.Query(
		ctx, exec,
		SelectWhere.TaggedmarkTags.TagID.EQ(TagIDPK),
		sm.Columns(TaggedmarkTagsTable.Columns().Only(cols...)),
	).One()
}

// TaggedmarkTagExists checks the presence of a single record by primary key
func TaggedmarkTagExists(ctx context.Context, exec bob.Executor, TagIDPK int64) (bool, error) {
	return TaggedmarkTagsTable.Query(
		ctx, exec,
		SelectWhere.TaggedmarkTags.TagID.EQ(TagIDPK),
	).Exists()
}

// Update uses an executor to update the TaggedmarkTag
func (o *TaggedmarkTag) Update(ctx context.Context, exec bob.Executor, cols ...string) (int64, error) {
	rowsAff, err := TaggedmarkTagsTable.Update(ctx, exec, o, cols...)
	if err != nil {
		return rowsAff, err
	}

	return rowsAff, nil
}

// Delete deletes a single TaggedmarkTag record with an executor
func (o *TaggedmarkTag) Delete(ctx context.Context, exec bob.Executor) (int64, error) {
	return TaggedmarkTagsTable.Delete(ctx, exec, o)
}

// Reload refreshes the TaggedmarkTag using the executor
func (o *TaggedmarkTag) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := TaggedmarkTagsTable.Query(
		ctx, exec,
		SelectWhere.TaggedmarkTags.TagID.EQ(o.TagID),
	).One()
	if err != nil {
		return err
	}
	o2.R = o.R
	*o = *o2

	return nil
}

func (o TaggedmarkTagSlice) DeleteAll(ctx context.Context, exec bob.Executor) (int64, error) {
	return TaggedmarkTagsTable.DeleteMany(ctx, exec, o...)
}

func (o TaggedmarkTagSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals TaggedmarkTagSetter) (int64, error) {
	rowsAff, err := TaggedmarkTagsTable.UpdateMany(ctx, exec, &vals, o...)
	if err != nil {
		return rowsAff, err
	}

	return rowsAff, nil
}

func (o TaggedmarkTagSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	var mods []bob.Mod[*dialect.SelectQuery]

	TagIDPK := make([]any, len(o))
	for i, o := range o {
		TagIDPK[i] = o.TagID
	}
	mods = append(mods, sm.Where(TaggedmarkTagColumns.TagID.In(TagIDPK...)))

	o2, err := TaggedmarkTags(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, old := range o {
		for _, new := range o2 {
			if new.TagID != old.TagID {
				continue
			}
			new.R = old.R
			*old = *new
			break
		}
	}

	return nil
}

// Taggedmark starts a query for related objects on taggedmark
func (o *TaggedmarkTag) Taggedmark(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) TaggedmarksQuery {
	return Taggedmarks(ctx, exec, append(mods,
		sm.Where(TaggedmarkColumns.ID.EQ(sqlite.Arg(o.TaggedmarkID))),
	)...)
}

func (os TaggedmarkTagSlice) Taggedmark(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) TaggedmarksQuery {
	PKArgs := make([]any, 0, len(os))
	for _, o := range os {
		PKArgs = append(PKArgs, sqlite.ArgGroup(o.TaggedmarkID))
	}

	return Taggedmarks(ctx, exec, append(mods,
		sm.Where(sqlite.Group(TaggedmarkColumns.ID).In(PKArgs...)),
	)...)
}

// Tag starts a query for related objects on tag
func (o *TaggedmarkTag) Tag(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) TagsQuery {
	return Tags(ctx, exec, append(mods,
		sm.Where(TagColumns.ID.EQ(sqlite.Arg(o.TagID))),
	)...)
}

func (os TaggedmarkTagSlice) Tag(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) TagsQuery {
	PKArgs := make([]any, 0, len(os))
	for _, o := range os {
		PKArgs = append(PKArgs, sqlite.ArgGroup(o.TagID))
	}

	return Tags(ctx, exec, append(mods,
		sm.Where(sqlite.Group(TagColumns.ID).In(PKArgs...)),
	)...)
}

func (o *TaggedmarkTag) Preload(name string, retrieved any) error {
	if o == nil {
		return nil
	}

	switch name {
	case "Taggedmark":
		rel, ok := retrieved.(*Taggedmark)
		if !ok {
			return fmt.Errorf("taggedmarkTag cannot load %T as %q", retrieved, name)
		}

		o.R.Taggedmark = rel

		if rel != nil {
			rel.R.TaggedmarkTags = TaggedmarkTagSlice{o}
		}
		return nil
	case "Tag":
		rel, ok := retrieved.(*Tag)
		if !ok {
			return fmt.Errorf("taggedmarkTag cannot load %T as %q", retrieved, name)
		}

		o.R.Tag = rel

		if rel != nil {
			rel.R.TaggedmarkTag = o
		}
		return nil
	default:
		return fmt.Errorf("taggedmarkTag has no relationship %q", name)
	}
}

func PreloadTaggedmarkTagTaggedmark(opts ...sqlite.PreloadOption) sqlite.Preloader {
	return sqlite.Preload[*Taggedmark, TaggedmarkSlice](orm.Relationship{
		Name: "Taggedmark",
		Sides: []orm.RelSide{
			{
				From:   "taggedmark_tag",
				To:     TableNames.Taggedmarks,
				ToExpr: TaggedmarksTable.Name,
				FromColumns: []string{
					ColumnNames.TaggedmarkTags.TaggedmarkID,
				},
				ToColumns: []string{
					ColumnNames.Taggedmarks.ID,
				},
			},
		},
	}, TaggedmarksTable.Columns().Names(), opts...)
}

func ThenLoadTaggedmarkTagTaggedmark(queryMods ...bob.Mod[*dialect.SelectQuery]) sqlite.Loader {
	return sqlite.Loader(func(ctx context.Context, exec bob.Executor, retrieved any) error {
		loader, isLoader := retrieved.(interface {
			LoadTaggedmarkTagTaggedmark(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
		})
		if !isLoader {
			return fmt.Errorf("object %T cannot load TaggedmarkTagTaggedmark", retrieved)
		}

		return loader.LoadTaggedmarkTagTaggedmark(ctx, exec, queryMods...)
	})
}

// LoadTaggedmarkTagTaggedmark loads the taggedmarkTag's Taggedmark into the .R struct
func (o *TaggedmarkTag) LoadTaggedmarkTagTaggedmark(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	related, err := o.Taggedmark(ctx, exec, mods...).One()
	if err != nil && !errors.Is(err, sql.ErrNoRows) {
		return err
	}

	related.R.TaggedmarkTags = TaggedmarkTagSlice{o}

	o.R.Taggedmark = related
	return nil
}

// LoadTaggedmarkTagTaggedmark loads the taggedmarkTag's Taggedmark into the .R struct
func (os TaggedmarkTagSlice) LoadTaggedmarkTagTaggedmark(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	taggedmarks, err := os.Taggedmark(ctx, exec, mods...).All()
	if err != nil && !errors.Is(err, sql.ErrNoRows) {
		return err
	}

	for _, rel := range taggedmarks {
		for _, o := range os {
			if o.TaggedmarkID != rel.ID {
				continue
			}

			rel.R.TaggedmarkTags = append(rel.R.TaggedmarkTags, o)

			o.R.Taggedmark = rel
			break
		}
	}

	return nil
}

func PreloadTaggedmarkTagTag(opts ...sqlite.PreloadOption) sqlite.Preloader {
	return sqlite.Preload[*Tag, TagSlice](orm.Relationship{
		Name: "Tag",
		Sides: []orm.RelSide{
			{
				From:   "taggedmark_tag",
				To:     TableNames.Tags,
				ToExpr: TagsTable.Name,
				FromColumns: []string{
					ColumnNames.TaggedmarkTags.TagID,
				},
				ToColumns: []string{
					ColumnNames.Tags.ID,
				},
			},
		},
	}, TagsTable.Columns().Names(), opts...)
}

func ThenLoadTaggedmarkTagTag(queryMods ...bob.Mod[*dialect.SelectQuery]) sqlite.Loader {
	return sqlite.Loader(func(ctx context.Context, exec bob.Executor, retrieved any) error {
		loader, isLoader := retrieved.(interface {
			LoadTaggedmarkTagTag(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
		})
		if !isLoader {
			return fmt.Errorf("object %T cannot load TaggedmarkTagTag", retrieved)
		}

		return loader.LoadTaggedmarkTagTag(ctx, exec, queryMods...)
	})
}

// LoadTaggedmarkTagTag loads the taggedmarkTag's Tag into the .R struct
func (o *TaggedmarkTag) LoadTaggedmarkTagTag(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	related, err := o.Tag(ctx, exec, mods...).One()
	if err != nil && !errors.Is(err, sql.ErrNoRows) {
		return err
	}

	related.R.TaggedmarkTag = o

	o.R.Tag = related
	return nil
}

// LoadTaggedmarkTagTag loads the taggedmarkTag's Tag into the .R struct
func (os TaggedmarkTagSlice) LoadTaggedmarkTagTag(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	tags, err := os.Tag(ctx, exec, mods...).All()
	if err != nil && !errors.Is(err, sql.ErrNoRows) {
		return err
	}

	for _, rel := range tags {
		for _, o := range os {
			if o.TagID != rel.ID {
				continue
			}

			rel.R.TaggedmarkTag = o

			o.R.Tag = rel
			break
		}
	}

	return nil
}

func (o *TaggedmarkTag) InsertTaggedmark(ctx context.Context, exec bob.Executor, related *TaggedmarkSetter) error {
	rel, err := TaggedmarksTable.Insert(ctx, exec, related)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}
	o.R.Taggedmark = rel

	o.TaggedmarkID = rel.ID

	o.R.Taggedmark.R.TaggedmarkTags = TaggedmarkTagSlice{o}

	return nil
}

func (o *TaggedmarkTag) AttachTaggedmark(ctx context.Context, exec bob.Executor, rel *Taggedmark) error {
	var err error

	o.TaggedmarkID = rel.ID

	_, err = rel.Update(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}
	o.R.Taggedmark = rel

	rel.R.TaggedmarkTags = append(rel.R.TaggedmarkTags, o)

	return nil
}

func (o *TaggedmarkTag) InsertTag(ctx context.Context, exec bob.Executor, related *TagSetter) error {
	rel, err := TagsTable.Insert(ctx, exec, related)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}
	o.R.Tag = rel

	o.TagID = rel.ID

	o.R.Tag.R.TaggedmarkTag = o

	return nil
}

func (o *TaggedmarkTag) AttachTag(ctx context.Context, exec bob.Executor, rel *Tag) error {
	var err error

	o.TagID = rel.ID

	_, err = rel.Update(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}
	o.R.Tag = rel

	rel.R.TaggedmarkTag = o

	return nil
}
