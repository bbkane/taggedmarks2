// Code generated by BobGen sqlite v0.15.5. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"

	"github.com/aarondl/opt/omit"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/sqlite"
	"github.com/stephenafamo/bob/dialect/sqlite/dialect"
	"github.com/stephenafamo/bob/dialect/sqlite/sm"
)

// Migration is an object representing the database table.
type Migration struct {
	Name string `db:"name,pk" json:"name" toml:"name" yaml:"name"`
}

// MigrationSlice is an alias for a slice of pointers to Migration.
// This should almost always be used instead of []Migration.
type MigrationSlice []*Migration

// MigrationsTable contains methods to work with the migrations table
var MigrationsTable = sqlite.NewTablex[*Migration, MigrationSlice, *MigrationSetter]("", "migrations")

// MigrationsQuery is a query on the migrations table
type MigrationsQuery = *sqlite.TableQuery[*Migration, MigrationSlice, *MigrationSetter]

// MigrationsStmt is a prepared statment on migrations
type MigrationsStmt = bob.QueryStmt[*Migration, MigrationSlice]

// MigrationSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type MigrationSetter struct {
	Name omit.Val[string] `db:"name,pk"`
}

type migrationColumnNames struct {
	Name string
}

var MigrationColumns = struct {
	Name sqlite.Expression
}{
	Name: sqlite.Quote("migrations", "name"),
}

type migrationWhere[Q sqlite.Filterable] struct {
	Name sqlite.WhereMod[Q, string]
}

func MigrationWhere[Q sqlite.Filterable]() migrationWhere[Q] {
	return migrationWhere[Q]{
		Name: sqlite.Where[Q, string](sqlite.Quote("migrations", "name")),
	}
}

// Migrations begins a query on migrations
func Migrations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) MigrationsQuery {
	return MigrationsTable.Query(ctx, exec, mods...)
}

// FindMigration retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindMigration(ctx context.Context, exec bob.Executor, NamePK string, cols ...string) (*Migration, error) {
	if len(cols) == 0 {
		return MigrationsTable.Query(
			ctx, exec,
			SelectWhere.Migrations.Name.EQ(NamePK),
		).One()
	}

	return MigrationsTable.Query(
		ctx, exec,
		SelectWhere.Migrations.Name.EQ(NamePK),
		sm.Columns(MigrationsTable.Columns().Only(cols...)),
	).One()
}

// MigrationExists checks the presence of a single record by primary key
func MigrationExists(ctx context.Context, exec bob.Executor, NamePK string) (bool, error) {
	return MigrationsTable.Query(
		ctx, exec,
		SelectWhere.Migrations.Name.EQ(NamePK),
	).Exists()
}

// Update uses an executor to update the Migration
func (o *Migration) Update(ctx context.Context, exec bob.Executor, cols ...string) (int64, error) {
	rowsAff, err := MigrationsTable.Update(ctx, exec, o, cols...)
	if err != nil {
		return rowsAff, err
	}

	return rowsAff, nil
}

// Delete deletes a single Migration record with an executor
func (o *Migration) Delete(ctx context.Context, exec bob.Executor) (int64, error) {
	return MigrationsTable.Delete(ctx, exec, o)
}

// Reload refreshes the Migration using the executor
func (o *Migration) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := MigrationsTable.Query(
		ctx, exec,
		SelectWhere.Migrations.Name.EQ(o.Name),
	).One()
	if err != nil {
		return err
	}

	*o = *o2

	return nil
}

func (o MigrationSlice) DeleteAll(ctx context.Context, exec bob.Executor) (int64, error) {
	return MigrationsTable.DeleteMany(ctx, exec, o...)
}

func (o MigrationSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals MigrationSetter) (int64, error) {
	rowsAff, err := MigrationsTable.UpdateMany(ctx, exec, &vals, o...)
	if err != nil {
		return rowsAff, err
	}

	return rowsAff, nil
}

func (o MigrationSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	var mods []bob.Mod[*dialect.SelectQuery]

	NamePK := make([]any, len(o))
	for i, o := range o {
		NamePK[i] = o.Name
	}
	mods = append(mods, sm.Where(MigrationColumns.Name.In(NamePK...)))

	o2, err := Migrations(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, old := range o {
		for _, new := range o2 {
			if new.Name != old.Name {
				continue
			}

			*old = *new
			break
		}
	}

	return nil
}
